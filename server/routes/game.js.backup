/**
 * @fileoverview Game Management API Routes
 *
 * This module provides HTTP endpoints for managing game resources including vessels,
 * fuel/CO2 purchases, user settings, vessel maintenance, marketing campaigns, and
 * vessel acquisitions. These endpoints proxy requests to the Shipping Manager game API
 * while adding validation and error handling.
 *
 * Key Features:
 * - Vessel management (list vessels in harbor, purchase new vessels, bulk repairs)
 * - Bunker operations (fuel and CO2 price monitoring and purchasing)
 * - Route management (depart all vessels at once)
 * - Marketing campaigns (view available campaigns, activate/renew)
 * - User settings retrieval (anchor points, company data)
 *
 * Why This Module:
 * - Consolidates all game resource management endpoints
 * - Provides validation before forwarding to game API
 * - Standardizes error responses across all game operations
 * - Enables automation features (auto-rebuy, auto-depart, auto-repair)
 *
 * Common Patterns:
 * - GET endpoints retrieve current state (prices, vessels, settings)
 * - POST endpoints perform actions (purchase, depart, repair)
 * - All endpoints include error handling with descriptive messages
 * - Graceful degradation (empty arrays instead of errors for UI-critical endpoints)
 *
 * @requires express - Router and middleware
 * @requires ../utils/api - API helper function (apiCall)
 * @module server/routes/game
 */

const express = require('express');
const { apiCall, apiCallWithRetry, getUserId } = require('../utils/api');
const gameapi = require('../gameapi');
const { broadcastToUser } = require('../websocket');
const fs = require('fs').promises;
const path = require('path');
const os = require('os');

const router = express.Router();

// Auto-depart log file path - use APPDATA when running as .exe
const LOG_DIR = process.pkg
  ? path.join(process.env.APPDATA || path.join(os.homedir(), '.config'), 'ShippingManagerCoPilot')
  : path.join(__dirname, '../..');

const AUTO_DEPART_LOG = path.join(LOG_DIR, 'auto-depart.log');

/** GET /api/vessel/get-vessels - Retrieves all vessels currently in harbor. Uses /game/index endpoint to get complete vessel list with status, cargo, maintenance needs, etc. */
router.get('/vessel/get-vessels', async (req, res) => {
  try {
    const data = await apiCallWithRetry('/game/index', 'POST', {});
    res.json({
      vessels: data.data.user_vessels || []
    });
  } catch (error) {
    console.error('Error getting vessels:', error);
    res.status(500).json({ error: 'Failed to retrieve vessels' });
  }
});

/** POST /api/user/get-company - Returns user company data including capacity values. */
router.post('/user/get-company', express.json(), async (req, res) => {
  try {
    const data = await apiCall('/user/get-company', 'POST', {});
    res.json(data);
  } catch (error) {
    console.error('Error fetching company data:', error);
    res.status(500).json({ error: 'Failed to fetch company data' });
  }
});

/** GET /api/user/get-settings - Retrieves user settings including anchor points (used for auto-rebuy calculations). */
router.get('/user/get-settings', async (req, res) => {
  try {
    const data = await apiCall('/user/get-user-settings', 'GET', {});
    res.json(data);
  } catch (error) {
    console.error('Error getting user settings:', error);
    res.status(500).json({ error: 'Failed to retrieve user settings' });
  }
});

/** GET /api/bunker/get-prices - Fetches current market prices for fuel and CO2. Critical for price alerts and auto-rebuy features. */
router.get('/bunker/get-prices', async (req, res) => {
  try {
    const data = await apiCall('/bunker/get-prices', 'POST', {});
    res.json(data);
  } catch (error) {
    console.error('Error getting bunker prices:', error);
    res.status(500).json({ error: 'Failed to retrieve bunker prices' });
  }
});

/**
 * POST /api/bunker/purchase-fuel - Purchases specified amount of fuel.
 * Validation: amount must be positive integer. Used by manual purchases and auto-rebuy automation.
 */
router.post('/bunker/purchase-fuel', express.json(), async (req, res) => {
  const { amount } = req.body;

  if (!amount || !Number.isInteger(amount) || amount <= 0) {
    return res.status(400).json({ error: 'Invalid amount' });
  }

  try {
    // API expects amount in kilograms, but we receive it in tons
    const amountInKg = amount * 1000;
    const data = await apiCall('/bunker/purchase-fuel', 'POST', { amount: amountInKg });

    // Broadcast bunker update to all clients (manual purchase)
    const userId = getUserId();
    if (userId && data.user) {
      // API doesn't return capacity fields - use cached values from autopilot
      const autopilot = require('../autopilot');
      const cachedCapacity = autopilot.getCachedCapacity(userId);

      broadcastToUser(userId, 'bunker_update', {
        fuel: data.user.fuel / 1000,
        co2: (data.user.co2 || data.user.co2_certificate) / 1000,
        cash: data.user.cash,
        maxFuel: cachedCapacity.maxFuel,
        maxCO2: cachedCapacity.maxCO2
      });

      // Broadcast notification to all clients
      const state = require('../state');
      const bunker = state.getBunkerState(userId);
      const prices = state.getPrices(userId);
      const totalCost = Math.round(amount * prices.fuel);

      console.log(`[Manual Fuel Purchase] User bought ${amount}t @ $${prices.fuel}/t = $${totalCost.toLocaleString('en-US')}`);

      broadcastToUser(userId, 'user_action_notification', {
        type: 'success',
        message: `‚õΩ <strong>Manual Purchase</strong><br><br>Purchased ${Math.round(amount).toLocaleString('en-US')}t Fuel @ $${prices.fuel}/t<br>Total Cost: $${totalCost.toLocaleString('en-US')}`
      });
    }

    res.json(data);
  } catch (error) {
    console.error('Error purchasing fuel:', error);

    // Broadcast error notification to all clients
    const userId = getUserId();
    if (userId) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `‚õΩ <strong>Purchase Failed</strong><br><br>${error.message}`
      });
    }

    res.status(500).json({ error: 'Failed to purchase fuel' });
  }
});

/**
 * POST /api/bunker/purchase-co2 - Purchases specified amount of CO2 certificates.
 * Validation: amount must be positive integer. Used by manual purchases and auto-rebuy automation.
 */
router.post('/bunker/purchase-co2', express.json(), async (req, res) => {
  const { amount } = req.body;

  if (!amount || !Number.isInteger(amount) || amount <= 0) {
    return res.status(400).json({ error: 'Invalid amount' });
  }

  try {
    // API expects amount in kilograms, but we receive it in tons
    const amountInKg = amount * 1000;
    const data = await apiCall('/bunker/purchase-co2', 'POST', { amount: amountInKg });

    // Broadcast bunker update to all clients (manual purchase)
    const userId = getUserId();
    if (userId && data.user) {
      // API doesn't return capacity fields - use cached values from autopilot
      const autopilot = require('../autopilot');
      const cachedCapacity = autopilot.getCachedCapacity(userId);

      broadcastToUser(userId, 'bunker_update', {
        fuel: data.user.fuel / 1000,
        co2: (data.user.co2 || data.user.co2_certificate) / 1000,
        cash: data.user.cash,
        maxFuel: cachedCapacity.maxFuel,
        maxCO2: cachedCapacity.maxCO2
      });

      // Broadcast notification to all clients
      const state = require('../state');
      const bunker = state.getBunkerState(userId);
      const prices = state.getPrices(userId);
      const totalCost = Math.round(amount * prices.co2);

      console.log(`[Manual CO2 Purchase] User bought ${amount}t @ $${prices.co2}/t = $${totalCost.toLocaleString('en-US')}`);

      broadcastToUser(userId, 'user_action_notification', {
        type: 'success',
        message: `üí® <strong>Manual Purchase</strong><br><br>Purchased ${Math.round(amount).toLocaleString('en-US')}t CO2 @ $${prices.co2}/t<br>Total Cost: $${totalCost.toLocaleString('en-US')}`
      });
    }

    res.json(data);
  } catch (error) {
    console.error('Error purchasing CO2:', error);

    // Broadcast error notification to all clients
    const userId = getUserId();
    if (userId) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `üí® <strong>Purchase Failed</strong><br><br>${error.message}`
      });
    }

    res.status(500).json({ error: 'Failed to purchase CO2' });
  }
});

/**
 * POST /api/route/depart - Universal depart endpoint
 * Accepts optional array of vessel IDs. If no IDs provided, departs ALL vessels in harbor.
 * Uses the EXACT same logic and notifications as autopilot.
 *
 * Request body (optional):
 * {
 *   vessel_ids: [123, 456, 789]  // Optional - if omitted, departs ALL vessels
 * }
 */
router.post('/route/depart', async (req, res) => {
  try {
    const userId = getUserId();
    const autopilot = require('../autopilot');

    // Extract vessel IDs from request body (optional)
    const vesselIds = req.body?.vessel_ids || null;

    if (vesselIds && !Array.isArray(vesselIds)) {
      return res.status(400).json({ error: 'vessel_ids must be an array' });
    }

    if (vesselIds) {
      console.log(`[Depart API] Departing ${vesselIds.length} specific vessels`);
    } else {
      console.log(`[Depart API] Departing ALL vessels in harbor`);
    }

    // Call universal depart function
    // vesselIds = null means "depart all"
    // vesselIds = [1,2,3] means "depart these specific vessels"
    await autopilot.departVessels(userId, vesselIds);

    res.json({ success: true, message: 'Depart triggered' });
  } catch (error) {
    console.error('[Depart API] Error:', error);
    res.status(500).json({ error: 'Failed to depart vessels' });
  }
});

/**
  try {
    const userId = getUserId();
    const gameapi = require('../gameapi');
    const autopilot = require('../autopilot');
    const state = require('../state');

    // Get user settings for utilization thresholds
    const settings = state.getSettings(userId) || {
      minVesselUtilization: 50,  // Default 50% minimum utilization
      autoDepartUseRouteDefaults: true,
      autoVesselSpeed: 100
    };

    // Fetch current data
    const vesselData = await apiCallWithRetry('/game/index', 'POST', {});
    const allVessels = vesselData.data.user_vessels || [];
    const assignedPorts = await gameapi.fetchAssignedPorts();

    // Use the SMART analysis from autopilot!
    const analysis = await autopilot.analyzeVesselDepartures(allVessels, assignedPorts, settings);

    console.log(`[Manual Depart All] Analysis: ${analysis.toDepart.length} profitable, ${analysis.toSkip.length} unprofitable`);

    // Report skipped vessels if any
    if (analysis.toSkip.length > 0) {
      const skipReasons = {};
      analysis.toSkip.forEach(({ vessel, reason }) => {
        if (!skipReasons[reason]) skipReasons[reason] = [];
        skipReasons[reason].push(vessel.name);
      });

      let skipMessage = `‚ö†Ô∏è <strong>Skipping ${analysis.toSkip.length} unprofitable vessels:</strong><br><br>`;
      for (const [reason, vessels] of Object.entries(skipReasons)) {
        skipMessage += `<strong>${reason}:</strong><br>`;
        skipMessage += vessels.slice(0, 5).join(', ');
        if (vessels.length > 5) skipMessage += `, ... (${vessels.length - 5} more)`;
        skipMessage += '<br><br>';
      }

      broadcastToUser(userId, 'user_action_notification', {
        type: 'warning',
        message: skipMessage
      });
    }

    // If no vessels to depart, stop here
    if (analysis.toDepart.length === 0) {
      // DISABLED: No notification for user (user request)
      // broadcastToUser(userId, 'user_action_notification', {
      //   type: 'info',
      //   message: 'üìä <strong>No profitable vessels to depart</strong><br><br>All vessels either lack demand at destination or would have too low utilization.'
      // });
      return res.json({ success: true, message: 'No profitable vessels to depart' });
    }

    // Process profitable vessels in chunks
    const CHUNK_SIZE = 20;
    let overallSuccessCount = 0;
    let totalVesselsSent = 0;  // Track total vessels processed
    let continueProcessing = true;
    let processedIndex = 0;

    // Overall statistics for the response
    let totalFuelUsage = 0;
    let totalCO2Emission = 0;
    let totalIncome = 0;
    let totalHarborFee = 0;

    // Keep track of already departed vessels
    const departedVesselIds = new Set();

    while (continueProcessing && processedIndex < analysis.toDepart.length) {
      // Before each chunk, refresh vessel data to get current status
      const currentVesselData = await apiCallWithRetry('/game/index', 'POST', {});
      const currentVessels = currentVesselData.data.user_vessels || [];
      const vesselsStillInPort = new Set(
        currentVessels
          .filter(v => v.status === 'port')
          .map(v => v.id)
      );

      // Take next chunk of profitable vessels, but filter out already departed ones
      const chunkEnd = Math.min(processedIndex + CHUNK_SIZE, analysis.toDepart.length);
      const plannedChunk = analysis.toDepart.slice(processedIndex, chunkEnd);
      const vesselChunk = plannedChunk.filter(vd =>
        vesselsStillInPort.has(vd.vessel.id) && !departedVesselIds.has(vd.vessel.id)
      );

      if (vesselChunk.length === 0) {
        console.log(`[Manual Depart All] No vessels from chunk ${processedIndex + 1}-${chunkEnd} are still in port, skipping...`);
        processedIndex = chunkEnd;
        continue;
      }

      console.log(`[Manual Depart All] Processing chunk: ${vesselChunk.length} vessels still in port (from planned ${plannedChunk.length})`);

      // Stats for this chunk only
      let successCount = 0;
      let failCount = 0;
      let chunkFuelUsed = 0;
      let chunkCO2Used = 0;
      let chunkIncome = 0;
      let chunkHarborFee = 0;
      const errors = [];

      // Process this chunk
      for (const vesselData of vesselChunk) {
        const vessel = vesselData.vessel;
        try {
          // Determine speed and guards
          let speed, guards;
          if (settings.autoDepartUseRouteDefaults) {
            speed = vessel.route_speed || vessel.max_speed;
            guards = vessel.route_guards || 0;
          } else {
            const speedPercent = settings.autoVesselSpeed;
            speed = Math.round(vessel.max_speed * (speedPercent / 100));
            guards = vessel.route_guards || 0;
          }

          const result = await gameapi.departVessel(vessel.id, speed, guards);

          if (result.success) {
            // Validate that we got all required values from the API
            if (typeof result.fuelUsed !== 'number' ||
                typeof result.co2Used !== 'number' ||
                typeof result.income !== 'number' ||
                typeof result.harborFee !== 'number') {
              throw new Error(`API returned incomplete data for vessel ${vessel.name}: ` +
                `fuelUsed=${result.fuelUsed}, co2Used=${result.co2Used}, ` +
                `income=${result.income}, harborFee=${result.harborFee}`);
            }

            successCount++;
            departedVesselIds.add(vessel.id); // Mark as departed
            // Add to chunk totals
            chunkFuelUsed += result.fuelUsed;
            chunkCO2Used += result.co2Used;
            chunkIncome += result.income;
            chunkHarborFee += result.harborFee;
            // Add to overall totals
            totalFuelUsage += result.fuelUsed;
            totalCO2Emission += result.co2Used;
            totalIncome += result.income;
            totalHarborFee += result.harborFee;
            console.log(`[Manual Depart All] ‚úì ${vessel.name} departed`);
          } else {
            // SPECIAL CASE: CO2 "errors" are not real errors - CO2 can go negative
            // The game API returns an error but still sends the vessel
            if (result.errorMessage && (result.errorMessage.toLowerCase().includes('co2') ||
                                       result.errorMessage.toLowerCase().includes('emission'))) {
              console.log(`[Manual Depart All] ‚úì ${vessel.name} departed (ignoring CO2 warning - CO2 can go negative)`);
              successCount++;
              departedVesselIds.add(vessel.id); // Mark as departed even with CO2 warning
              // We don't have the actual values but vessel was sent
              // Continue without adding to errors
            } else {
              failCount++;
              errors.push({ vessel: vessel.name, error: result.errorMessage });
              console.log(`[Manual Depart All] ‚úó ${vessel.name} failed: ${result.errorMessage}`);
            }
          }
        } catch (error) {
          failCount++;
          errors.push({ vessel: vessel.name, error: error.message });
          console.log(`[Manual Depart All] ‚úó ${vessel.name} error: ${error.message}`);
        }
      }

      overallSuccessCount += successCount;
      totalVesselsSent += vesselChunk.length;

      // Send notification for this chunk
      if (successCount > 0 || failCount > 0) {
        const chunkNetIncome = chunkIncome - chunkHarborFee;
        const chunkTotal = successCount + failCount;

        // Build notification based on chunk results
        if (successCount === chunkTotal) {
          // All vessels in chunk departed successfully
          const statsHTML = `<br><br>‚õΩ Fuel used: ${chunkFuelUsed.toLocaleString()}t<br>üí® CO2 emitted: ${chunkCO2Used.toLocaleString()}t<br>üí∞ Net income: $${chunkNetIncome.toLocaleString()}<br><span style="opacity: 0.7; font-size: 0.9em;">(Income: $${chunkIncome.toLocaleString()} - Fee: $${chunkHarborFee.toLocaleString()})</span>`;

          broadcastToUser(userId, 'user_action_notification', {
            type: 'success',
            message: `üö¢ <strong>${successCount} vessel${successCount === 1 ? '' : 's'} departed!</strong>${statsHTML}`
          });
        } else if (successCount > 0 && failCount > 0) {
          // Some vessels failed in this chunk
          let errorList = '';
          if (errors.length > 0) {
            // Group errors by type to make them more compact
            const errorGroups = {};
            errors.forEach(err => {
              const key = err.error || 'Unknown error';
              if (!errorGroups[key]) {
                errorGroups[key] = [];
              }
              errorGroups[key].push(err.vessel);
            });

            // Create compact error list
            const errorLines = [];
            for (const [error, vessels] of Object.entries(errorGroups)) {
              if (vessels.length === 1) {
                errorLines.push(`${vessels[0]}: ${error}`);
              } else {
                // Show only first 2 vessels and count for this error type
                const preview = vessels.slice(0, 2).join(', ');
                const more = vessels.length > 2 ? ` (+${vessels.length - 2} more)` : '';
                errorLines.push(`${preview}${more}: ${error}`);
              }
            }
            errorList = errorLines.join('<br>');
          }

          broadcastToUser(userId, 'user_action_notification', {
            type: 'warning',
            message: `üö¢ <strong>${successCount}/${chunkTotal} departed</strong><br><br>‚õΩ ${chunkFuelUsed.toLocaleString()}t | üí® ${chunkCO2Used.toLocaleString()}t | üí∞ $${chunkNetIncome.toLocaleString()}<br><br>‚ö†Ô∏è Failed: ${failCount} vessels<br><span style="font-size: 0.85em;">${errorList}</span>`
          });
        } else if (failCount === chunkTotal) {
          // All vessels in chunk failed
          let errorSummary = '';
          if (errors.length > 0) {
            // Group errors by type for compact display
            const errorGroups = {};
            errors.forEach(err => {
              const key = err.error || 'Unknown error';
              errorGroups[key] = (errorGroups[key] || 0) + 1;
            });

            // Create summary
            const errorCounts = Object.entries(errorGroups)
              .map(([error, count]) => `${count}x: ${error}`)
              .join('<br>');
            errorSummary = errorCounts;
          }

          // Fetch current bunker state for error message
          const bunkerState = await gameapi.fetchBunkerState();

          broadcastToUser(userId, 'user_action_notification', {
            type: 'error',
            message: `üö¢ <strong>No vessels departed!</strong><br><br>‚õΩ ${bunkerState?.fuel ? bunkerState.fuel.toFixed(1) + 't' : 'N/A'} | üí® ${bunkerState?.co2 ? bunkerState.co2.toFixed(1) + 't' : 'N/A'}<br><br>‚ö†Ô∏è ${failCount} failures:<br><span style="font-size: 0.85em;">${errorSummary}</span>`
          });
        }

        // Trigger auto-rebuy after each chunk with successful departures (if enabled)
        if (successCount > 0) {
          const autopilot = require('../autopilot');
          console.log(`[Manual Depart All] Triggering auto-rebuy after ${successCount} vessels departed in this batch`);
          autopilot.autoRebuy().catch(err => {
            console.error('[Manual Depart All] Auto-rebuy error:', err.message);
          });
        }
      }

      // Move to next chunk
      processedIndex = chunkEnd;
    } // End of chunk processing loop

    // After all chunks are processed, update vessel counts and bunker state
    if (userId) {
      // Fetch updated vessel count AFTER all departures
      const vesselData = await apiCallWithRetry('/game/index', 'POST', {});
      const allVessels = vesselData.data.user_vessels || [];
      const readyToDepart = allVessels.filter(v => v.status === 'port').length;
      const atAnchor = allVessels.filter(v => v.status === 'anchor').length;
      const pending = allVessels.filter(v => v.status === 'pending').length;

      broadcastToUser(userId, 'vessel_count_update', {
        readyToDepart,
        atAnchor,
        pending
      });

      // Also broadcast bunker update (fuel/CO2 consumed)
      if (vesselData.user) {
        const autopilot = require('../autopilot');
        const cachedCapacity = autopilot.getCachedCapacity(userId);

        broadcastToUser(userId, 'bunker_update', {
          fuel: vesselData.user.fuel / 1000,
          co2: (vesselData.user.co2 || vesselData.user.co2_certificate) / 1000,
          cash: vesselData.user.cash,
          maxFuel: cachedCapacity.maxFuel,
          maxCO2: cachedCapacity.maxCO2
        });
      }
    }

    // Return response structure that frontend expects
    res.json({
      success: true,
      message: `Analyzed ${allVessels.filter(v => v.status === 'port').length} vessels: ${analysis.toDepart.length} departed (profitable), ${analysis.toSkip.length} skipped (unprofitable)`,
      data: {
        depart_info: {
          vessel_count: totalVesselsSent,
          fuel_usage: totalFuelUsage,
          co2_emission: totalCO2Emission,
          depart_income: totalIncome,
          harbor_fee: totalHarborFee
        }
      }
    });
  } catch (error) {
    console.error('Error departing vessels:', error);

    // Broadcast error notification to all clients
    const userId = getUserId();
    if (userId) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `üö¢ <strong>Error</strong><br><br>${error.message}`
      });
    }

    res.status(500).json({ error: 'Failed to depart vessels' });
  }
});

/**
 * POST /api/route/depart - Departs a single vessel on its assigned route.
 * Used by intelligent auto-depart to send only profitable vessels.
 * Validation: user_vessel_id and speed are required.
 * @param {number} user_vessel_id - The vessel ID to depart
 * @param {number} speed - Speed to travel at (usually % of max_speed)
 * @param {number} guards - Number of guards (0 or 10 based on hijacking_risk)
 * @param {number} history - History parameter (default 0, purpose unclear)
 */
router.post('/route/depart', express.json(), async (req, res) => {
  const { user_vessel_id, speed, guards, history } = req.body;

  if (!user_vessel_id || !speed) {
    return res.status(400).json({ error: 'Missing user_vessel_id or speed' });
  }

  try {
    const data = await apiCall('/route/depart', 'POST', {
      user_vessel_id,
      speed,
      guards: guards || 0,
      history: history || 0
    });

    // Log auto-depart action to file
    if (data.data?.depart_info) {
      const departInfo = data.data.depart_info;
      const vesselData = data.data.user_vessels?.[0];
      const timestamp = new Date().toISOString();
      const logEntry = `[${timestamp}] Vessel: ${vesselData?.name || user_vessel_id} | ` +
        `Destination: ${vesselData?.route_destination || 'unknown'} | ` +
        `Income: $${departInfo.depart_income || 0} | ` +
        `Harbor Fee: $${departInfo.harbor_fee || 0} | ` +
        `Net: $${(departInfo.depart_income || 0) - (departInfo.harbor_fee || 0)} | ` +
        `Fuel: ${((departInfo.fuel_usage || 0) / 1000).toFixed(2)}t | ` +
        `CO2: ${((departInfo.co2_emission || 0) / 1000).toFixed(2)}t | ` +
        `Speed: ${speed}kn | Guards: ${guards || 0}\n`;

      try {
        await fs.appendFile(AUTO_DEPART_LOG, logEntry);
      } catch (logError) {
        console.error('[Auto-Depart Log] Failed to write:', logError);
      }

      // Trigger auto-rebuy after vessel departure (if enabled)
      const autopilot = require('../autopilot');
      console.log('[Manual Depart] Triggering auto-rebuy check after departure');
      autopilot.autoRebuy().catch(err => {
        console.error('[Manual Depart] Auto-rebuy error:', err.message);
      });
    }

    res.json(data);
  } catch (error) {
    console.error('Error departing vessel:', error);
    res.status(500).json({ error: 'Failed to depart vessel' });
  }
});

/**
 * GET /api/port/get-assigned-ports - Retrieves demand and consumed data for all assigned ports.
 * Used by intelligent auto-depart to calculate remaining port capacity.
 * Returns port demand/consumed for both container and tanker cargo types.
 * @returns {Object} data.ports - Array of port objects with demand/consumed data
 */
router.get('/port/get-assigned-ports', async (req, res) => {
  try {
    const data = await apiCall('/port/get-assigned-ports', 'POST', {});
    res.json(data);
  } catch (error) {
    console.error('Error fetching assigned ports:', error);
    res.status(500).json({ error: 'Failed to fetch assigned ports' });
  }
});

/** POST /api/maintenance/get - Calculates maintenance cost for specified vessels. Returns total repair cost and individual vessel costs. */
router.post('/maintenance/get', express.json(), async (req, res) => {
  const { vessel_ids } = req.body;

  if (!vessel_ids) {
    return res.status(400).json({ error: 'Missing vessel_ids' });
  }

  try {
    const data = await apiCall('/maintenance/get', 'POST', { vessel_ids });
    res.json(data);
  } catch (error) {
    console.error('Error getting maintenance cost:', error);
    res.status(500).json({ error: 'Failed to get maintenance cost' });
  }
});

/** POST /api/maintenance/do-wear-maintenance-bulk - Performs bulk wear maintenance on multiple vessels. Repairs all specified vessels in a single API call. */
router.post('/maintenance/do-wear-maintenance-bulk', express.json(), async (req, res) => {
  const { vessel_ids } = req.body;

  if (!vessel_ids) {
    return res.status(400).json({ error: 'Missing vessel_ids' });
  }

  try {
    const data = await apiCall('/maintenance/do-wear-maintenance-bulk', 'POST', { vessel_ids });
    res.json(data);
  } catch (error) {
    console.error('Error performing bulk maintenance:', error);
    res.status(500).json({ error: 'Failed to perform bulk maintenance' });
  }
});

/**
 * GET /api/marketing/get-campaigns - Retrieves available marketing campaigns and active campaign status.
 * Graceful error handling: Returns empty arrays instead of error to prevent UI breaking.
 */
router.get('/marketing/get-campaigns', async (req, res) => {
  try {
    const data = await apiCall('/marketing-campaign/get-marketing', 'POST', {});
    res.json(data);
  } catch (error) {
    console.error('Error getting marketing campaigns:', error.message, error.stack);

    // Return empty campaigns instead of error to prevent UI breaking
    res.json({
      data: {
        marketing_campaigns: [],
        active_campaigns: []
      },
      user: {
        reputation: 0
      }
    });
  }
});

/** POST /api/marketing/activate-campaign - Activates a marketing campaign by campaign_id. Used for manual activation and auto-renewal automation. */
router.post('/marketing/activate-campaign', express.json(), async (req, res) => {
  const { campaign_id } = req.body;

  if (!campaign_id) {
    return res.status(400).json({ error: 'Missing campaign_id' });
  }

  try {
    const data = await apiCall('/marketing-campaign/activate-marketing-campaign', 'POST', { campaign_id });
    res.json(data);
  } catch (error) {
    console.error('Error activating campaign:', error);
    res.status(500).json({ error: 'Failed to activate campaign' });
  }
});

/** GET /api/vessel/get-all-acquirable - Fetches all vessels available for purchase from the marketplace. */
router.get('/vessel/get-all-acquirable', async (req, res) => {
  try {
    const data = await apiCall('/vessel/get-all-acquirable-vessels', 'POST', {});
    res.json(data);
  } catch (error) {
    console.error('Error getting acquirable vessels:', error);
    res.status(500).json({ error: 'Failed to retrieve acquirable vessels' });
  }
});

/**
 * POST /api/vessel/sell-vessels - Sells multiple vessels by their IDs.
 * Accepts an array of vessel IDs and sells each one individually.
 * Broadcasts notifications and bunker updates to all connected clients.
 */
router.post('/vessel/sell-vessels', express.json(), async (req, res) => {
  const { vessel_ids } = req.body;

  if (!vessel_ids || !Array.isArray(vessel_ids) || vessel_ids.length === 0) {
    return res.status(400).json({ error: 'Missing or invalid vessel_ids array' });
  }

  try {
    let soldCount = 0;
    const errors = [];

    // Sell each vessel individually (API only supports single vessel sales)
    for (const vesselId of vessel_ids) {
      try {
        const data = await apiCall('/vessel/sell-vessel', 'POST', { vessel_id: vesselId });
        if (data.success) {
          soldCount++;
        }
      } catch (error) {
        console.error(`[Vessel Sell] Failed to sell vessel ${vesselId}:`, error.message);
        errors.push({ vesselId, error: error.message });
      }
    }

    const userId = getUserId();
    if (userId && soldCount > 0) {
      console.log(`[Manual Vessel Sell] User sold ${soldCount} vessel(s)`);

      // Broadcast notification to all clients
      broadcastToUser(userId, 'user_action_notification', {
        type: 'success',
        message: `‚õ¥Ô∏è <strong>Vessels Sold!</strong><br><br>Successfully sold ${soldCount} vessel${soldCount > 1 ? 's' : ''}`
      });

      // Fetch and broadcast updated bunker state (cash increased)
      try {
        const gameData = await apiCallWithRetry('/game/index', 'POST', {});
        if (gameData.data?.user) {
          const user = gameData.data.user;

          // API doesn't return capacity fields - use cached values from autopilot
          const autopilot = require('../autopilot');
          const cachedCapacity = autopilot.getCachedCapacity(userId);

          broadcastToUser(userId, 'bunker_update', {
            fuel: user.fuel / 1000,
            co2: (user.co2 || user.co2_certificate) / 1000,
            cash: user.cash,
            maxFuel: cachedCapacity.maxFuel,
            maxCO2: cachedCapacity.maxCO2
          });
        }
      } catch (error) {
        console.error('[Vessel Sell] Failed to fetch updated bunker state:', error);
      }
    }

    res.json({
      success: true,
      sold: soldCount,
      errors: errors.length > 0 ? errors : undefined
    });

  } catch (error) {
    console.error('[Vessel Sell] Error:', error);
    const userId = getUserId();
    if (userId) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `‚õ¥Ô∏è <strong>Sale Failed</strong><br><br>${error.message}`
      });
    }
    res.status(500).json({ error: 'Failed to sell vessels' });
  }
});

/**
 * POST /api/vessel/purchase-vessel - Purchases a new vessel with specified configuration.
 * Default configuration: 4-blade propeller, optional antifouling, no enhanced deck beams.
 * Validation: vessel_id and name are required fields.
 */
router.post('/vessel/purchase-vessel', express.json(), async (req, res) => {
  const { vessel_id, name, antifouling_model, count, silent } = req.body;

  if (!vessel_id || !name) {
    return res.status(400).json({ error: 'Missing required fields: vessel_id, name' });
  }

  try {
    const data = await apiCall('/vessel/purchase-vessel', 'POST', {
      vessel_id,
      name,
      adjust_speed: '4_blade_propeller',
      antifouling_model: antifouling_model || null,
      enhanced_deck_beams: 0
    });

    const userId = getUserId();
    if (userId && data.user_vessel && !silent) {
      const vesselName = data.user_vessel.name || name;
      const purchaseCount = count || 1;

      console.log(`[Manual Vessel Purchase] User bought ${purchaseCount}x ${vesselName}`);

      // Broadcast notification to all clients (unless silent=true)
      broadcastToUser(userId, 'user_action_notification', {
        type: 'success',
        message: `üö¢ <strong>Purchase Successful!</strong><br><br>Purchased ${purchaseCount}x ${vesselName}`
      });
    }

    // Always broadcast bunker update (cash decreased)
    if (userId && data.user) {
      broadcastToUser(userId, 'bunker_update', {
        fuel: data.user.fuel / 1000,
        co2: (data.user.co2 || data.user.co2_certificate) / 1000,
        cash: data.user.cash,
        maxFuel: data.user.fuel_capacity / 1000,
        maxCO2: data.user.co2_certificate_capacity / 1000
      });
    }

    res.json(data);
  } catch (error) {
    console.error('Error purchasing vessel:', error);

    const userId = getUserId();
    if (userId && !silent) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `üö¢ <strong>Purchase Failed</strong><br><br>${error.message}`
      });
    }

    res.status(500).json({ error: 'Failed to purchase vessel' });
  }
});

/**
 * POST /api/vessel/broadcast-purchase-summary - Broadcasts a summary notification of vessel purchases to all clients
 */
router.post('/vessel/broadcast-purchase-summary', express.json(), async (req, res) => {
  const { vessels, totalCost } = req.body;

  if (!vessels || !Array.isArray(vessels)) {
    return res.status(400).json({ error: 'Missing required field: vessels (array)' });
  }

  const userId = getUserId();
  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    // Build vessel list HTML
    let vesselListHtml = '';
    if (vessels.length > 5) {
      // If more than 5, show scrollable list
      vesselListHtml = '<div style="max-height: 200px; overflow-y: auto; margin: 10px 0; padding-right: 5px;"><ul style="margin: 0; padding-left: 20px; text-align: left;">';
      vessels.forEach(v => {
        vesselListHtml += `<li>${v.name}</li>`;
      });
      vesselListHtml += '</ul></div>';
    } else {
      // If 5 or fewer, show simple list
      vesselListHtml = '<br>';
      vessels.forEach(v => {
        vesselListHtml += `${v.name}<br>`;
      });
    }

    const message = `üö¢ <strong>Purchased ${vessels.length} vessel${vessels.length > 1 ? 's' : ''}!</strong>${vesselListHtml}Total Cost: $${totalCost.toLocaleString()}`;

    broadcastToUser(userId, 'user_action_notification', {
      type: 'success',
      message
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error broadcasting purchase summary:', error);
    res.status(500).json({ error: 'Failed to broadcast summary' });
  }
});

/** POST /api/vessel/get-repair-preview - Gets repair preview with vessel list and costs */
router.post('/vessel/get-repair-preview', express.json(), async (req, res) => {
  const { threshold } = req.body;

  if (!threshold || threshold < 0 || threshold > 100) {
    return res.status(400).json({ error: 'Invalid threshold' });
  }

  try {
    // Get all vessels
    const vesselData = await apiCallWithRetry('/game/index', 'POST', {});
    const allVessels = vesselData.data.user_vessels || [];
    const user = vesselData.user;

    // Filter vessels needing repair
    const vesselsToRepair = allVessels.filter(v => {
      const wear = parseInt(v.wear) || 0;
      return wear >= threshold;
    });

    if (vesselsToRepair.length === 0) {
      return res.json({ vessels: [], totalCost: 0, cash: user.cash });
    }

    // Get repair costs
    const vesselIds = vesselsToRepair.map(v => v.id);
    const costData = await gameapi.getMaintenanceCost(vesselIds);

    // Build vessel details with costs
    const vesselDetails = vesselsToRepair.map(vessel => {
      const costVessel = costData.vessels.find(v => v.id === vessel.id);
      const wearMaintenance = costVessel?.maintenance_data?.find(m => m.type === 'wear');
      const cost = wearMaintenance?.price || 0;
      return {
        id: vessel.id,
        name: vessel.name,
        wear: vessel.wear,
        cost: cost
      };
    });

    // Calculate total cost
    const calculatedTotalCost = vesselDetails.reduce((sum, v) => sum + v.cost, 0);
    const finalTotalCost = costData.totalCost > 0 ? costData.totalCost : calculatedTotalCost;

    res.json({
      vessels: vesselDetails,
      totalCost: finalTotalCost,
      cash: user.cash
    });

  } catch (error) {
    console.error('Error getting repair preview:', error);
    res.status(500).json({ error: 'Failed to get repair preview' });
  }
});

/** POST /api/vessel/bulk-repair - Repairs all vessels needing maintenance based on threshold */
router.post('/vessel/bulk-repair', express.json(), async (req, res) => {
  const { threshold } = req.body;

  if (!threshold || threshold < 0 || threshold > 100) {
    return res.status(400).json({ error: 'Invalid threshold' });
  }

  try {
    // Get all vessels
    const vesselData = await apiCallWithRetry('/game/index', 'POST', {});
    const allVessels = vesselData.data.user_vessels || [];

    // Filter vessels needing repair
    const vesselsToRepair = allVessels.filter(v => {
      const wear = parseInt(v.wear) || 0;
      return wear >= threshold;
    });

    if (vesselsToRepair.length === 0) {
      const userId = getUserId();
      if (userId) {
        broadcastToUser(userId, 'user_action_notification', {
          type: 'info',
          message: 'üîß No vessels need repair!'
        });
      }
      return res.json({ count: 0, totalCost: 0 });
    }

    // Get repair costs
    const vesselIds = vesselsToRepair.map(v => v.id);
    const costData = await gameapi.getMaintenanceCost(vesselIds);
    const totalCost = costData.totalCost;

    // Build vessel details with costs
    const vesselDetails = vesselsToRepair.map(vessel => {
      const costVessel = costData.vessels.find(v => v.id === vessel.id);
      const wearMaintenance = costVessel?.maintenance_data?.find(m => m.type === 'wear');
      const cost = wearMaintenance?.price || 0;
      console.debug(`[Bulk Repair] Vessel ${vessel.name} (ID: ${vessel.id}): wear=${vessel.wear}%, cost=$${cost}`);
      return {
        id: vessel.id,
        name: vessel.name,
        wear: vessel.wear,
        cost: cost
      };
    });

    // Recalculate totalCost from vessel details (in case API returned 0)
    const calculatedTotalCost = vesselDetails.reduce((sum, v) => sum + v.cost, 0);
    console.debug(`[Bulk Repair] Total calculated from vessels: $${calculatedTotalCost.toLocaleString()}, costData.totalCost: $${costData.totalCost.toLocaleString()}`);

    // Check cash (use calculatedTotalCost if totalCost is 0)
    const finalTotalCost = totalCost > 0 ? totalCost : calculatedTotalCost;
    const state = require('../state');
    const userId = getUserId();
    const bunker = state.getBunkerState(userId);

    if (finalTotalCost > bunker.cash) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `üîß <strong>Not enough cash!</strong><br><br>Repair cost: $${totalCost.toLocaleString()}<br>Your cash: $${bunker.cash.toLocaleString()}<br>Missing: $${(totalCost - bunker.cash).toLocaleString()}`
      });
      return res.status(400).json({ error: 'Not enough cash' });
    }

    // Execute repairs
    const repairData = await gameapi.bulkRepairVessels(vesselIds);

    // Use repairData.totalCost if available (API sometimes returns it), otherwise use finalTotalCost
    const actualCost = repairData.totalCost > 0 ? repairData.totalCost : finalTotalCost;

    console.debug(`[Manual Bulk Repair] Repaired ${vesselsToRepair.length} vessels - costData.totalCost: $${totalCost.toLocaleString()}, calculatedTotalCost: $${calculatedTotalCost.toLocaleString()}, repairData.totalCost: $${repairData.totalCost.toLocaleString()}, Using: $${actualCost.toLocaleString()}`);

    // Broadcast success to all clients
    if (userId) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'success',
        message: `üîß <strong>${vesselsToRepair.length} vessels repaired!</strong><br><br>üí∞ Total cost: $${actualCost.toLocaleString()}<br>üîß Wear threshold: ${threshold}%`
      });

      // Update bunker cash
      broadcastToUser(userId, 'bunker_update', {
        fuel: bunker.fuel,
        co2: bunker.co2,
        cash: bunker.cash - actualCost,
        maxFuel: bunker.maxFuel,
        maxCO2: bunker.maxCO2
      });
    }

    res.json({
      count: vesselsToRepair.length,
      totalCost: actualCost,
      vessels: vesselDetails
    });
  } catch (error) {
    console.error('Error repairing vessels:', error);

    const userId = getUserId();
    if (userId) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'error',
        message: `üîß <strong>Error</strong><br><br>${error.message}`
      });
    }

    res.status(500).json({ error: 'Failed to repair vessels' });
  }
});

/** POST /api/check-price-alerts - Manually trigger price alert check (called on page load) */
router.post('/check-price-alerts', async (req, res) => {
  try {
    const autopilot = require('../autopilot');
    await autopilot.checkPriceAlerts();
    res.json({ success: true });
  } catch (error) {
    console.error('[API] Failed to check price alerts:', error.message);
    res.status(500).json({ error: 'Failed to check price alerts' });
  }
});

/** POST /api/autopilot/trigger-depart - Event-driven auto-depart trigger (called when vessels arrive in harbor) */
router.post('/autopilot/trigger-depart', async (req, res) => {
  try {
    const userId = getUserId();
    const autopilot = require('../autopilot');
    const state = require('../state');

    const settings = state.getSettings(userId);

    // Only execute if auto-depart is enabled
    if (!settings?.autoDepartAll) {
      return res.json({ success: false, message: 'Auto-depart not enabled' });
    }

    console.log(`[Auto-Depart] Event-driven trigger received for user ${userId}`);

    // Execute auto-depart directly
    await autopilot.autoDepartVessels(userId);

    res.json({ success: true, message: 'Auto-depart triggered' });
  } catch (error) {
    console.error('[Auto-Depart] Trigger failed:', error);
    res.status(500).json({ error: 'Failed to trigger auto-depart' });
  }
});

/**
 * POST /api/autopilot/toggle - Pause/Resume autopilot
 *
 * Toggles autopilot paused state. When paused, the central autopilot monitor
 * still runs on its schedule, but skips all actions (depart, repair, rebuy, etc.).
 * Header data updates continue to run normally.
 */
router.post('/autopilot/toggle', async (req, res) => {
  try {
    const userId = getUserId();
    const autopilot = require('../autopilot');
    const { broadcast } = require('../websocket');

    // Toggle paused state in autopilot.js (global state)
    const currentlyPaused = autopilot.isAutopilotPaused();
    const newPausedState = !currentlyPaused;

    if (newPausedState) {
      autopilot.pauseAutopilot();
    } else {
      autopilot.resumeAutopilot();
    }

    const status = newPausedState ? 'paused' : 'resumed';
    console.log(`[Autopilot] User ${userId} ${status} autopilot`);

    // Broadcast status to all connected clients
    broadcast('autopilot_status', {
      paused: newPausedState,
      message: `Autopilot ${status}`
    });

    res.json({
      success: true,
      paused: newPausedState,
      message: `Autopilot ${status}`
    });
  } catch (error) {
    console.error('[Autopilot] Toggle failed:', error);
    res.status(500).json({ error: 'Failed to toggle autopilot' });
  }
});

/**
 * GET /api/autopilot/status - Get current autopilot pause status
 *
 * Returns the current autopilot paused state (global state from autopilot.js).
 * Used on page load to sync button state across all devices.
 */
router.get('/autopilot/status', async (req, res) => {
  try {
    const autopilot = require('../autopilot');

    const isPaused = autopilot.isAutopilotPaused();

    res.json({
      success: true,
      paused: isPaused
    });
  } catch (error) {
    console.error('[Autopilot] Get status failed:', error);
    res.status(500).json({ error: 'Failed to get autopilot status' });
  }
});

module.exports = router;
